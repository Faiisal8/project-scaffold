package config

import (
	"errors"
	"fmt"
	"log/slog"
	"os"
	"strconv"
	"time"

	"github.com/joho/godotenv"
)

type Config struct {
	AppPort string
	AppEnv  string

	DBHost     string
	DBPort     string
	DBUser     string
	DBPassword string
	DBName     string
	DBSSLMode  string

	LogLevel slog.Level

	HTTPReadTimeout  time.Duration
	HTTPWriteTimeout time.Duration
	HTTPIdleTimeout  time.Duration
	ShutdownTimeout  time.Duration
}

func Load() (Config, error) {
	// Best-effort: allow local dev to use .env without requiring it in production.
	_ = godotenv.Load()

	logLevel, err := parseLogLevel(getenvDefault("LOG_LEVEL", "info"))
	if err != nil {
		return Config{}, err
	}

	readTimeout, err := parseDuration(getenvDefault("HTTP_READ_TIMEOUT", "5s"))
	if err != nil {
		return Config{}, fmt.Errorf("HTTP_READ_TIMEOUT: %w", err)
	}
	writeTimeout, err := parseDuration(getenvDefault("HTTP_WRITE_TIMEOUT", "10s"))
	if err != nil {
		return Config{}, fmt.Errorf("HTTP_WRITE_TIMEOUT: %w", err)
	}
	idleTimeout, err := parseDuration(getenvDefault("HTTP_IDLE_TIMEOUT", "60s"))
	if err != nil {
		return Config{}, fmt.Errorf("HTTP_IDLE_TIMEOUT: %w", err)
	}
	shutdownTimeout, err := parseDuration(getenvDefault("SHUTDOWN_TIMEOUT", "10s"))
	if err != nil {
		return Config{}, fmt.Errorf("SHUTDOWN_TIMEOUT: %w", err)
	}

	cfg := Config{
		AppPort: getenvDefault("APP_PORT", "8080"),
		AppEnv:  getenvDefault("APP_ENV", "development"),

		DBHost:     getenvDefault("DB_HOST", "localhost"),
		DBPort:     getenvDefault("DB_PORT", "5432"),
		DBUser:     getenvDefault("DB_USER", "postgres"),
		DBPassword: getenvDefault("DB_PASSWORD", "postgres"),
		DBName:     getenvDefault("DB_NAME", "{{.ProjectName}}"),
		DBSSLMode:  getenvDefault("DB_SSLMODE", "disable"),

		LogLevel: logLevel,

		HTTPReadTimeout:  readTimeout,
		HTTPWriteTimeout: writeTimeout,
		HTTPIdleTimeout:  idleTimeout,
		ShutdownTimeout:  shutdownTimeout,
	}

	if cfg.AppPort == "" {
		return Config{}, errors.New("APP_PORT is required")
	}
	if cfg.DBHost == "" || cfg.DBPort == "" || cfg.DBUser == "" || cfg.DBName == "" {
		return Config{}, errors.New("database configuration is incomplete")
	}

	return cfg, nil
}

func getenvDefault(key, def string) string {
	if v, ok := os.LookupEnv(key); ok {
		return v
	}
	return def
}

func parseDuration(s string) (time.Duration, error) {
	return time.ParseDuration(s)
}

func parseLogLevel(s string) (slog.Level, error) {
	switch s {
	case "debug":
		return slog.LevelDebug, nil
	case "info":
		return slog.LevelInfo, nil
	case "warn", "warning":
		return slog.LevelWarn, nil
	case "error":
		return slog.LevelError, nil
	default:
		// Accept numeric levels too (slog supports it).
		if n, err := strconv.Atoi(s); err == nil {
			return slog.Level(n), nil
		}
		return 0, fmt.Errorf("invalid LOG_LEVEL %q (use: debug|info|warn|error)", s)
	}
}

func (c Config) PostgresConnString() string {
	// Keep it explicit and predictable. If your password contains special chars, consider URL-encoding.
	return fmt.Sprintf(
		"postgres://%s:%s@%s:%s/%s?sslmode=%s",
		c.DBUser, c.DBPassword, c.DBHost, c.DBPort, c.DBName, c.DBSSLMode,
	)
}

